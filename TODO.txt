- Expand the -t output to be even more useful. Make sure callbacks
  (events) are also handled.

- Change terminology in code and comments: "Original application" =
  for example Word or Excel. "Replacement application" = for example
  Collabora Office. "Proxied application" is too unclear, we use the
  "proxy" term too much already.

- Including a coclass should automatically also include its default
  interface and default source interface, if any. (For instance, if
  Word.Application is mentioned in the -I file, it should not be
  necessary to mention Word._Application and Word.ApplicationEvents4.)

- Make sure we have just one CProxiedFoo object for each real COM
  object. Currently we can get several if a method that creates one
  causes a callback first where the real object is passed as a
  parameter.

  For instance: during the call to genericInvoke() in
  CWord_Documents::Open() a DocumentOpen event is generated and then
  in the DocumentOpen case in Word_ApplicationEvents4.cxx we create a
  new CWord_Document to proxy it. (That is needed in case the event
  handler calls interesting stuff on the object that we want to trace
  or wrap.) Back in CWord_Documents::Open(), after genericInvoke has
  returned, we again create a new CWord_Document to proxy the return
  value from that function.

- A VT_UNKNOWN VARIANT is an IUnknown pointer. (It is not something
  "unknown" and weird.) We probably need to handle such in some
  places.

- Add detection of type of objects returned from enumerations: Add a
  way to check if the objects if of some of the types of interfaces
  that we handle, and in that case proxy it.

  For objects returned as out parameters from methods or from property
  getters I think it already works like that. At least the latter.
  Anyway, some out parameters or retvals are marked to be just
  IDispatch*, but presumably could actually be some type we know?

- Print out parameters also in CProxiedDispatch::Invoke, like in the
  generated proxy methods.
