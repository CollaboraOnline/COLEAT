- Expand the -t output to be even more useful. Make sure callbacks
  (events) are also handled.

- Change terminology in code and comments: "Original application" =
  for example Word or Excel. "Replacement application" = for example
  Collabora Office. "Proxied application" is too unclear, we use the
  "proxy" term too much already.

- Including a coclass should automatically also include its default
  interface and default source interface, if any. (For instance, if
  Word.Application is mentioned in the -I file, it should not be
  necessary to mention Word._Application and Word.ApplicationEvents4.)

- Make sure we have just one CProxiedFoo object for each real COM
  object. Currently we can get several if a method that creates one
  causes a callback first where the real object is passed as a
  parameter.

  For instance: during the call to genericInvoke() in
  CWord_Documents::Open() a DocumentOpen event is generated and then
  in the DocumentOpen case in Word_ApplicationEvents4.cxx we create a
  new CWord_Document to proxy it. (That is needed in case the event
  handler calls interesting stuff on the object that we want to trace
  or wrap.) Back in CWord_Documents::Open(), after genericInvoke has
  returned, we again create a new CWord_Document to proxy the return
  value from that function.

  Commit 4deff7ec7bb883c93dc42ef5960867267bf3360f attempts to handle
  this, not sure if it is enough.

- A VT_UNKNOWN VARIANT is an IUnknown pointer. (It is not something
  "unknown" and weird.) We probably need to handle such in some
  places.

- Add detection of type of objects returned from enumerations: Add a
  way to check if the objects if of some of the types of interfaces
  that we handle, and in that case proxy it.

  For objects returned as out parameters from methods or from property
  getters I think it already works like that. At least the latter.
  Anyway, some out parameters or retvals are marked to be just
  IDispatch*, but presumably could actually be some type we know?

- Print out parameters also in CProxiedDispatch::Invoke, like in the
  generated proxy methods.

- When doing no redirection, just tracing, as long as the client uses
  late binding, we should be able to trace also interfaces we haven't
  generated any proxies for, as long as all the necessary type
  information is available at run-time. I have more or less ignored
  that approach path since I started looking into VB6-created clients
  that use early binding where we can trace (or redirect) only
  interfaces for which we have generated proxies beforehand.

  (Obviously it would be meaningless to do redirection of unknown
  interfaces; how would the replacement app know what they do?)
